# Именные функции def_имя
# def my_sum(arg_1, arg_2)
# res = arg_1 + arg_2
# Именной блок кода (функция) выносится в самый верх кода.
# pass заглушка, чтобы дописать функцию позже и не выдавать ошибку
def my_function():
    # pass
    print('Hi')


# Если в теле функции есть print, то повторный вызов print вызовит None
# Если в теле функции нету print и надо её вызвать, то нужно добавить print
print(my_function())
my_function()
print('*' * 33)


def my_f(s_1, s_2):
    sub = s_1 - s_2
    print(f'Sub: {sub}')


my_f(34, 14)
# def my_f(s_1, s_2): позиционные-обязательные аргументы print(my_f(34,14)
# def my_f(s_1, s_2=20): s_2=20 необязательные аргументы print(my_f(10))
print('*' * 33)


def my_f1(s_1, s_2=34):
    sub = s_1 - s_2
    print(f'Sub: {sub}')


my_f1(334)
# Если нужно, то можно добавить новое значение необязательному аргументу
my_f1(334, 300)
# def my_f1(s_1=30, s_2): это ошибка
my_f(s_2=340, s_1=45)
# Получение значений от пользователя
# my_f1(s_2=int(input('s_2: ')), s_1=int(input('s_1: ')))
# my_f1(int(input('s_1: ')), (int(input('s_2: '))))
# Получение значений в теле функции
# def my_f1():
#     s_1 = int(input('s_1: '))
#     s_2 = (int(input('s_2: ')
#     sub = s_1 - s_2
#     print(f'Sub: {sub}')
print('*' * 33)
# return возвращает значение, но не выводит его на экран.
# def my_f1():
#     s_1 = int(input('s_1: '))
#     s_2 = (int(input('s_2: ')
#     sub = s_1 - s_2
#     return f'Sub: {sub}'
# print(my_f1()) для отображения результата при return
# return завершает работу функции. Всегда будет последним действием даже если после него будут
# другие команды. return цикле функции аналог brake,чтобы завершить в нужном месте
# при return нескольких объектов(значений), то вывод будет формлен в кортеже (2, 45, False)
# Для получения списка return [sub, 45, False]
# def my_f(*args) передача неограниченного количества аргументов
# return args
# Далее в теле функции можно производить все необходимые операци
# Именновованные параметры **kwargs (неограниченное количество)
# def my_f1(**kwargs):
# return kwargs
# print(my_f(s=34, g=56, y=89)) при выводе получим словарь {'s':34}
# Анонимные функции def adn lambda
# lambda в неё уже вшит return. Скобки не нужны
# my_func = lambda p_1, p_2: p_1 + p_2
# print(my_func(2, 5))
# Используется редко, чтобы не перегружать код
my = lambda s_1, s_2: s_2 - s_1
print(my(23, 45))
print((lambda s_1, s_2: s_2 - s_1)(23, 45))
print((lambda *args: args)(23, 45))
# Встроенные функции ord() , chr(), len()
# ord находится ли слово в диапазоне
print(ord('a'))
print(ord('b'))
print(ord('z'))
# сhr
print(chr(12345))
print(chr(12346))
# abs() получить число без знака (избавиться от минуса)
# round() округляет число до целого или определенного знака после запятой
# divmod() резльтат от целочисленного деления и от остатка от деления

# pow() Два числа. Позволяет возвести первое число в указанную степень
# max() возврщает самый большой элемент
# min() возвращает самый наименьший элемент
# sum() суммирует элементы последовательности
print(abs(-78))
print(round(8.6546))
print(round(8.6546, 2))
print(divmod(8, 5))
# 8 // 5 , 8 % 5
print(pow(2, 3))
print(max('1231243428'))
print(min('12345435'))
print('*' * 33)
print(max(2, 4, 2))
print(min(2, 4, 2))
print('*' * 33)
print(max([2, -4, 2]))
print(min([2, -4, 2]))
print(sum([2, 4, 6]))
print('*' * 33)
# Выполняется благодаря ord
print(max(['g', '3', 'ы', '9']))
print(min(['g', '3', 'ы', '9']))
print('*' * 33)
# range
print(range(7))
print(list(range(7)))
print(list(range(7, 17)))
print('*' * 33)
# 3 это шаг
print(list(range(7, 17, 3)))
print(list(range(70, 17, -3)))
print('*' * 33)
# Не работает range(2.3) range('d') range()
# Четные
print(list(range(0, 27, 2)))
# Нечетные
print(list(range(1, 27, 2)))


# Области видимости функции
# Локальная область видимости - внутри блока функции. Вне блока взаимодействовать нельзя
# Глобальная находится сверху функции
# оператор global выводит локальные переменные функции. Доступна за пределами функции.
# global используется редко, принесолькоки указываются через запятую
# global m, f
# Нелокальная область видимости
# Функция с переменной содержит внутри себя еще одну функцию, которая увеличивает значение
# локальной переменной my_var на 1 и возвращает результат, а большая возвращает рузльтат мале
# нькой функции
def ext_func():
    my_var = 10

    def in_func():
        nonlocal my_var
        my_var += 1
        return my_var

    return in_func()


print(ext_func())


# Документирование кода функций
# Однострочное
#  """Возвращает путь до директории."""
#  """ Возвращает частное от деления.
# Многострочное
# Именованные параметрые:
#  p_1 -- делимое (по умолчанию 0.0)
#  p_2 -- делитель (по умолчанию 0.0)


def get_path():
    """Возвращает путь до директории."""

    global my_path
    if my_path:
        return my_path


def get_path1(p_1=0, p_2=1):
    """Возвращает путь до директории.
    Именованные параметрые:
    p_1 -- делимое (по умолчанию 0.0)
    p_2 -- делитель (по умолчанию 0.0)

    """
    return p_1 / p_2
